<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Jitsi Meet AutoStart</title>
  <style>
    :root {
      --bg: #0b0f19;
      --fg: #e6e7eb;
      --muted: #9aa3b2;
      --accent: #4ea1ff;
      --panel: #12182a;
      --panel2: #0f1526;
      --border: #24304a;
    }

    html,
    body {
      height: 100%;
      margin: 0;
    }

    body {
      background: var(--bg);
      color: var(--fg);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, "Helvetica Neue", Arial;
      display: flex;
      flex-direction: column;
    }

    #topbar {
      background: linear-gradient(180deg, var(--panel), var(--panel2));
      border-bottom: 1px solid var(--border);
      padding: 10px 14px;
      display: flex;
      gap: 12px;
      align-items: center;
      flex-wrap: wrap;
      position: sticky;
      top: 0;
      z-index: 10;
    }

    .kv {
      display: flex;
      gap: 6px;
      align-items: center;
    }

    .label {
      color: var(--muted);
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: .06em;
      display: flex;
      flex-direction: column;
      /* Arranges items vertically */
      align-items: flex-start;
    }

    .value {
      font-weight: 600;
    }

    #statusDot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: #999;
      display: inline-block;
      vertical-align: middle;
      margin-right: 6px;
    }

    #controls {
      margin-left: auto;
      display: flex;
      gap: 8px;
      align-items: center;
    }

    button,
    input[type="text"],
    input[type="url"] {
      background: #0c1222;
      color: var(--fg);
      border: 1px solid var(--border);
      padding: 6px 10px;
      border-radius: 8px;
      font-size: 14px;
    }

    button {
      cursor: pointer;
    }

    button.primary {
      background: #16305a;
      border-color: #20457f;
    }

    button:disabled {
      opacity: .6;
      cursor: not-allowed;
    }

    #editPanel {
      display: none;
      width: 100%;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
    }

    #editPanel input {
      min-width: 280px;
    }

    #test {
      height: calc(100vh - 60px);
      width: 100%;
    }

    label.checkbox {
      font-size: 13px;
      display: flex;
      align-items: center;
      gap: 6px;
      cursor: pointer;
    }
  </style>
</head>

<body>
  <!-- Top bar showing current config + quick controls -->
  <div id="topbar">
    <div class="kv">
      <span id="statusDot" title="Reachability"></span>
      <span class="label">Status</span>
      <span class="value" id="statusText">Checking…</span>
    </div>
    <div class="kv">
      <span class="label">Server URL</span>
      <span class="value" id="serverDisplay">—</span>
    </div>
    <div class="kv">
      <span class="label">RoomID</span>
      <span class="value" id="roomDisplay">—</span>
    </div>
    <div class="kv">
      <span class="label">Offline Reload</span>
      <span class="value" id="reloadDisplay">—</span>
    </div>
    <div id="controls">
      <button id="editBtn">Edit</button>
      <button id="saveBtn" class="primary" style="display:none">Save & Join</button>
      <button id="rejoinBtn">Rejoin</button>
    </div>
    <div id="editPanel">
      <label>
        <span class="label">Server URL</span>
        <input id="serverInput" type="url" placeholder="https://meet.jit.si" />
      </label>
      <label>
        <span class="label">RoomID</span>
        <input id="roomInput" type="text" placeholder="" />
      </label>
      <label>
        <span class="label">Offline Reload</span>
        <input type="checkbox" id="offlineReloadChk" />
      </label>
    </div>
  </div>

  <!-- Container for the Jitsi iframe -->
  <div id="test"></div>

  <script>
    // ------- Persistence helpers -------
    const STORAGE_KEYS = {
      server: 'jitsiServerURL',
      room: 'jitsiRoomID',
      offlineReload: 'jitsiOfflineReload'
    };

    function getStoredConfig() {
      const server = localStorage.getItem(STORAGE_KEYS.server) || 'https://meet.jit.si';
      const room = localStorage.getItem(STORAGE_KEYS.room) || crypto.randomUUID();
      const offlineReload = localStorage.getItem(STORAGE_KEYS.offlineReload) || 'false';
      return { server, room, offlineReload: offlineReload === 'true' };
    }
    function setStoredConfig({ server, room, offlineReload }) {
      if (server !== undefined) localStorage.setItem(STORAGE_KEYS.server, server);
      if (room !== undefined) localStorage.setItem(STORAGE_KEYS.room, room);
      if (offlineReload !== undefined) localStorage.setItem(STORAGE_KEYS.offlineReload, offlineReload);
    }

    const serverDisplay = document.getElementById('serverDisplay');
    const roomDisplay = document.getElementById('roomDisplay');
    const reloadDisplay = document.getElementById('reloadDisplay');
    const statusDot = document.getElementById('statusDot');
    const statusText = document.getElementById('statusText');
    const editBtn = document.getElementById('editBtn');
    const saveBtn = document.getElementById('saveBtn');
    const editPanel = document.getElementById('editPanel');
    const serverInput = document.getElementById('serverInput');
    const roomInput = document.getElementById('roomInput');
    const rejoinBtn = document.getElementById('rejoinBtn');
    const offlineReloadChk = document.getElementById('offlineReloadChk');

    function showConfig({ server, room, offlineReload }) {
      serverDisplay.textContent = server;
      roomDisplay.textContent = room;
      reloadDisplay.textContent = offlineReload;
      serverInput.value = server;
      roomInput.value = room;
      offlineReloadChk.checked = offlineReload;
    }
    function toggleEdit(on) {
      editPanel.style.display = on ? 'flex' : 'none';
      saveBtn.style.display = on ? '' : 'none';
      editBtn.style.display = on ? 'none' : '';
      rejoinBtn.style.display = on ? 'none' : '';
    }

    // ------- Reachability + script loader -------
    function normalizeBase(urlStr) {
      try {
        const u = new URL(urlStr);
        // strip trailing slash
        return u.origin;
      } catch {
        // Fallback to default if parse fails
        return DEFAULTS.server;
      }
    }
    async function checkReachability(baseUrl) {
      try {
        // HEAD preferred; fall back to GET if blocked
        const res = await fetch(`${baseUrl}/ping`, { method: 'HEAD', mode: 'cors' });
        return res.ok;
      } catch {
        try {
          const res = await fetch(`${baseUrl}/ping`, { method: 'GET', mode: 'cors', cache: 'no-store' });
          return res.ok;
        } catch {
          return false;
        }
      }
    }
    function checkJitsiAPI() {
      return typeof window.JitsiMeetExternalAPI !== "undefined";
    }
    function setStatus(ok) {
      if (ok == null) {
        statusDot.style.background = '#c4c4c4';
        statusText.textContent = '';

      } else {
        statusDot.style.background = ok ? '#22c55e' : '#f43f5e';
        statusText.textContent = ok ? 'Online' : 'Offline';
      }

    }

    let api = null;           // Jitsi API instance
    let probeTimer = null;   // periodic reload when unreachable
    let ensureVideoTimer = null; //periodic enable video timer

    function clearApi() {
      if (api && typeof api.dispose === 'function') {
        try { api.dispose(); } catch { }
      }
      api = null;
      const container = document.getElementById('test');
      container.innerHTML = ''; // remove old iframe if any

      clearInterval(probeTimer);
      clearInterval(ensureVideoTimer);
    }

    function loadExternalScript(baseUrl) {
      return new Promise((resolve, reject) => {
        // If already loaded, resolve
        if (checkJitsiAPI()) return resolve();

        const script = document.createElement('script');
        script.src = `${baseUrl}/external_api.js`;
        script.async = true;
        script.onload = resolve;
        script.onerror = reject;
        document.head.appendChild(script);
      });
    }

    function getDomainFromBase(baseUrl) {
      try {
        return new URL(baseUrl).host; // Jitsi API wants host (no protocol)
      } catch {
        return new URL(DEFAULTS.server).host;
      }
    }

    async function startOrRejoin() {
      const { server, room, offlineReload } = getStoredConfig();
      showConfig({ server, room, offlineReload });
      const base = normalizeBase(server);

      // Load Jitsi API if necessary
      if (!checkJitsiAPI()) {
        await loadExternalScript(base);
      }

      clearApi();
      const domain = getDomainFromBase(base);
      api = new JitsiMeetExternalAPI(domain, {
        roomName: room,
        parentNode: document.querySelector('#test'),
        configOverwrite: {
          prejoinConfig: { enabled: false },
          requireDisplayName: false,
          startWithAudioMuted: true,
          startWithVideoMuted: false,
          disableDeepLinking: false
        },
        onload: function() {
          // Rejoin conference if it is closed
          api.addListener('readyToClose', ({}) => {
            startOrRejoin();
          });
        }
      });

      //Hide room name
      api.executeCommand('subject', ' ');

      // Ensure camera is on (as in your original)
      const ensureVideo = () => {
        if (!api) return;
        api.isVideoMuted().then(muted => {
          if (muted) api.executeCommand('toggleVideo');
        }).catch(() => { });
      };

      // // first try shortly after join, then every 3s for a bit
      if (ensureVideoTimer) clearInterval(ensureVideoTimer);
      ensureVideoTimer = setInterval(ensureVideo, 3000);

      if (probeTimer) clearInterval(probeTimer);
      if (offlineReload) {
        const ok = await checkReachability(base);
        setStatus(ok);
        probeTimer = setInterval(async () => {
          const ok = await checkReachability(base);
          setStatus(ok);
          // if it becomes reachable and no API yet, try to (re)join
          if (!ok || !checkJitsiAPI()) {
            try {
              await startOrRejoin();
            } catch { }
          }
        }, 10000);
      } else {
        setStatus(null);
        clearInterval(probeTimer);
      }
    }

    // ------- Event wiring -------
    editBtn.addEventListener('click', () => {
      toggleEdit(true);
      clearApi();
    });
    saveBtn.addEventListener('click', async () => {
      const server = serverInput.value.trim(), room = roomInput.value.trim();
      setStoredConfig({ server, room });
      toggleEdit(false);
      await startOrRejoin();
    });
    rejoinBtn.addEventListener('click', async () => await startOrRejoin());
    offlineReloadChk.addEventListener('change', async (e) => {
      setStoredConfig({ offlineReload: e.target.checked });
    });

    // ------- Boot -------
    (function boot() {
      // Seed defaults on first run if nothing stored
      const existing = getStoredConfig();
      setStoredConfig(existing);
      showConfig(existing);
      startOrRejoin();
    })();

  </script>
</body>

</html>